package db

import (
	"context"
	"encoding/gob"
	"time"

	"github.com/alexedwards/scs/v2"
	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgxpool"
)

type DB struct {
	pool    *pgxpool.Pool
	session *scs.SessionManager
}

type UserSessionData struct {
	Username                               string
	IsAuthenticated, IsAdmin, IsOTPEnabled bool
}

type User struct {
	Username     string
	PasswordHash []byte
	IsAdmin      bool
}

type Event struct {
	ID            int64
	Author        string
	Title         string
	Description   string
	GeoJSON       string
	DatetimeStart *time.Time
	DatetimeEnd   *time.Time
	CreatedAt     time.Time
}

type EventID struct {
	ID     int64
	Author string
}

func Create(dbPool *pgxpool.Pool, sessionManager *scs.SessionManager) DB {
	gob.Register(UserSessionData{})
	return DB{dbPool, sessionManager}
}

func (db DB) UserSessionDataCreateIfDoesNotExist(ctx context.Context) {
	if !db.session.Exists(ctx, "UserSessionData") {
		db.session.Put(ctx, "UserSessionData", UserSessionData{})
	}
}

func (db DB) UserSessionDataGet(ctx context.Context) UserSessionData {
	data := db.session.Get(ctx, "UserSessionData").(UserSessionData)
	return data
}

func (db DB) UserSessionDataSet(data UserSessionData, ctx context.Context) {
	db.session.Put(ctx, "UserSessionData", data)
}

func (db DB) UserSessionDataDestroy(ctx context.Context) {
	db.session.Destroy(ctx)
}

func (db DB) UserExists(username string) (bool, error) {
	var exists bool
	err := db.pool.QueryRow(context.Background(), "select exists (select 1 from users where username = $1)", username).Scan(&exists)
	return exists, err
}

func (db DB) UserIsAdmin(username string) (bool, error) {
	var isAdmin bool
	err := db.pool.QueryRow(context.Background(), "select is_admin from users where username = $1", username).Scan(&isAdmin)
	return isAdmin, err
}

func (db DB) UserIsOTPEnabled(username string) (bool, error) {
	var isOTPEnabled bool
	err := db.pool.QueryRow(context.Background(), "select exists (select 1 from otp where username = $1)", username).Scan(&isOTPEnabled)
	return isOTPEnabled, err
}

func (db DB) UserTokenRenew(ctx context.Context) {
	db.session.RenewToken(ctx)
}

func (db DB) UserInsert(username string, passwordHash []byte, isAdmin bool) error {
	_, err := db.pool.Exec(context.Background(), "insert into users (username, password_hash, is_admin) values ($1, $2, $3)", username, passwordHash, isAdmin)
	return err
}

func (db DB) UserPasswordHashGet(username string) ([]byte, error) {
	var passwordHash []byte
	err := db.pool.QueryRow(context.Background(), "select password_hash from users where username = $1", username).Scan(&passwordHash)
	return passwordHash, err
}

func (db DB) UserPasswordHashSet(username string, newHash []byte) error {
	_, err := db.pool.Exec(context.Background(), "update users set password_hash = $1 where username = $2", newHash, username)
	return err
}

func (db DB) UserTableGet() ([]User, error) {
	rows, err := db.pool.Query(context.Background(), "select * from users;")
	if err != nil {
		return nil, err
	}
	users, err := pgx.CollectRows(rows, pgx.RowToStructByName[User])
	return users, err
}

func (db DB) UserOTPSecretInsert(username string, otpSecret []byte) error {
	_, err := db.pool.Exec(context.Background(), "insert into otp (username, otp) values ($1, $2)", username, otpSecret)
	return err
}

func (db DB) UserOTPSecretGet(username string) ([]byte, error) {
	var otpSecret []byte
	err := db.pool.QueryRow(context.Background(), "select otp from otp where username = $1", username).Scan(&otpSecret)
	return otpSecret, err
}

func (db DB) UserOTPSecretDelete(username string) error {
	_, err := db.pool.Exec(context.Background(), "delete from otp where username = $1", username)
	return err
}

func (db DB) SessionPut(key string, value interface{}, ctx context.Context) {
	db.session.Put(ctx, key, value)
}

func (db DB) SessionGet(key string, ctx context.Context) interface{} {
	secret := db.session.Get(ctx, key)
	return secret
}

func (db DB) SessionRemove(key string, ctx context.Context) {
	db.session.Remove(ctx, key)
}

// This function updates event id after insertion, because ids are generated by the database
func (db DB) EventInsert(e *Event) error {
	_, err := db.pool.Exec(context.Background(),
		"insert into events (author, title, description, geojson, datetime_start, datetime_end, created_at) values ($1, $2, $3, $4, $5, $6, $7)",
		e.Author, e.Title, e.Description, e.GeoJSON, e.DatetimeStart, e.DatetimeEnd, e.CreatedAt,
	)
	if err != nil {
		return err
	}

	err = db.pool.QueryRow(context.Background(), "select id from events where author = $1 order by id desc limit 1", e.Author).Scan(&e.ID)
	return err
}

func (db DB) EventGet(id EventID) (Event, error) {
	var e Event
	err := db.pool.QueryRow(context.Background(),
		`
		select id, author, title, description, geojson, datetime_start at time zone 'utc' as datetime_start, datetime_end at time zone 'utc' as datetime_end, created_at at time zone 'utc' as created_at
		from events
		where id = $1 and author = $2`,
		id.ID, id.Author,
	).Scan(&e.ID, &e.Author, &e.Title, &e.Description, &e.GeoJSON, &e.DatetimeStart, &e.DatetimeEnd, &e.CreatedAt)
	return e, err
}

func (db DB) UserEventGetPage(username string, pageSize, page int) ([]Event, error) {
	rows, err := db.pool.Query(context.Background(),
		`
		select id, author, title, description, geojson, datetime_start at time zone 'utc' as datetime_start, datetime_end at time zone 'utc' as datetime_end, created_at at time zone 'utc' as created_at
		from events
		where author = $1
		order by created_at desc limit $2 offset $3`,
		username, pageSize, pageSize*page,
	)
	if err != nil {
		return nil, err
	}
	e, err := pgx.CollectRows(rows, pgx.RowToStructByName[Event])
	return e, err
}

func (db DB) UserEventGetAll(username string) ([]Event, error) {
	rows, err := db.pool.Query(context.Background(),
		`select id, author, title, description, geojson, datetime_start at time zone 'utc' as datetime_start, datetime_end at time zone 'utc' as datetime_end, created_at at time zone 'utc' as created_at
		from events where author = $1`,
		username,
	)
	if err != nil {
		return nil, err
	}
	e, err := pgx.CollectRows(rows, pgx.RowToStructByName[Event])
	return e, err
}

func (db DB) UserFollowerInsert(followee, follower string) error {
	_, err := db.pool.Exec(context.Background(),
		"insert into followers (followee, follower) values ($1, $2)",
		followee, follower,
	)
	return err
}

func (db DB) UserFollowersGet(username string) ([]string, error) {
	rows, err := db.pool.Query(context.Background(),
		"select follower from followers where followee = $1", username,
	)
	if err != nil {
		return nil, err
	}
	f, err := pgx.CollectRows(rows, pgx.RowTo[string])
	return f, err
}

func (db DB) EventLinkInsert(from, to EventID) error {
	_, err := db.pool.Exec(context.Background(),
		"insert into event_links (id_from, author_from, id_to, author_to) values ($1, $2, $3, $4)",
		from.ID, from.Author, to.ID, to.Author,
	)
	return err
}

func (db DB) EventLinksInsert(from EventID, to []EventID) error {
	if len(to) == 0 {
		return nil
	}

	for _, t := range to {
		err := db.EventLinkInsert(from, t)
		if err != nil {
			return err
		}
	}
	return nil
}

func (db DB) EventLinksGetAll(from EventID) ([]Event, error) {
	rows, err := db.pool.Query(context.Background(),
		`
		select id, author, title, description, geojson, datetime_start at time zone 'utc' as datetime_start, datetime_end at time zone 'utc' as datetime_end, created_at at time zone 'utc' as created_at
		from events e
		where (id, author) in (
			select id, author
			from event_links l
			where l.id_from = $1 and l.author_from = $2
		)
		order by created_at desc
		`,
		from.ID, from.Author,
	)
	if err != nil {
		return nil, err
	}
	e, err := pgx.CollectRows(rows, pgx.RowToStructByName[Event])
	return e, err
}

func (db DB) EventLinksGetPage(from EventID, pageSize, page int) ([]Event, error) {
	rows, err := db.pool.Query(context.Background(),
		`
		select id, author, title, description, geojson, datetime_start at time zone 'utc' as datetime_start, datetime_end at time zone 'utc' as datetime_end, created_at at time zone 'utc' as created_at
		from events e
		where (id, author) in (
			select id_to, author_to
			from event_links l
			where id_from = $1 and author_from = $2
		)
		order by created_at desc limit $3 offset $4
		`,
		from.ID, from.Author, pageSize, pageSize*page,
	)
	if err != nil {
		return nil, err
	}
	e, err := pgx.CollectRows(rows, pgx.RowToStructByName[Event])
	return e, err
}

func (db DB) EventSearch(websearch string, pageSize, page int) ([]Event, error) {
	if websearch == "" {
		rows, err := db.pool.Query(context.Background(),
			`
			select id, author, title, description, geojson, datetime_start at time zone 'utc' as datetime_start, datetime_end at time zone 'utc' as datetime_end, created_at at time zone 'utc' as created_at
			from events
			order by created_at desc
			limit $1 offset $2
			`,
			pageSize, pageSize*page,
		)
		if err != nil {
			return nil, err
		}
		e, err := pgx.CollectRows(rows, pgx.RowToStructByName[Event])
		return e, err
	}

	rows, err := db.pool.Query(context.Background(),
		`
		select id, author, title, description, geojson, datetime_start at time zone 'utc' as datetime_start, datetime_end at time zone 'utc' as datetime_end, created_at at time zone 'utc' as created_at
		from events
		where
		to_tsvector('english', coalesce(author, '')) || to_tsvector('english', coalesce(title, '')) || to_tsvector('english', coalesce(description, ''))
		@@ websearch_to_tsquery('english', coalesce($1, '')) = 't'
		or
		to_tsvector('russian', coalesce(author, '')) || to_tsvector('russian', coalesce(title, '')) || to_tsvector('russian', coalesce(description, ''))
		@@ websearch_to_tsquery('russian', coalesce($1, '')) = 't'
		order by created_at desc
		limit $2 offset $3
		`,
		websearch, pageSize, pageSize*page,
	)
	if err != nil {
		return nil, err
	}
	e, err := pgx.CollectRows(rows, pgx.RowToStructByName[Event])
	return e, err
}
